# The following code is JUST PROOF OF CONCEPT and will NOT BE USED FOR THE FINAL IMPLEMENTATION
# This code was generated by ChatGPT and supposedlly uses PyGame to simulate a blue ball using an MPC with an Optimization Function to follow a randomly moving red ball
# I say supposedly because every time I run the code, it crashes, if this code works on anyones computer, please let me know

import numpy as np
import cvxpy as cp
import pygame
import random

pygame.init()

# Screen settings
screen_width, screen_height = 800, 600
screen = pygame.display.set_mode((screen_width, screen_height))
clock = pygame.time.Clock()

# Colors
BLUE = (0, 0, 255)
RED = (255, 0, 0)
WHITE = (255, 255, 255)

# System Parameters (2D Kinematic Model)
dt = 0.2  # Increased timestep to reduce update frequency
N = 4  # Further reduced horizon for lower computational load
A = np.array([[1, dt], [0, 1]])
B = np.array([[0], [dt]])
Q = np.eye(2) * 0.3  # Reduce weight on state error
R = np.eye(1) * 0.02  # Reduce control effort cost

# Initial Conditions
x = np.array([[400], [0]])
y = np.array([[300], [0]])

# Initialize red ball position and movement direction
target_x, target_y = random.randint(50, screen_width - 50), random.randint(50, screen_height - 50)
red_dx = random.choice([-1, 1])  # Slower movement
red_dy = random.choice([-1, 1])

# Cache previous control inputs
u_cache = np.array([[0], [0]])
frame_counter = 0

def mpc_control(target_x, target_y, x0, y0):
    global u_cache
    try:
        X = cp.Variable((2, N + 1))
        Y = cp.Variable((2, N + 1))
        Ux = cp.Variable((1, N))
        Uy = cp.Variable((1, N))

        target_x_vec = np.array([[target_x], [0]])
        target_y_vec = np.array([[target_y], [0]])

        cost = 0
        constraints = [X[:, 0] == x0, Y[:, 0] == y0]

        for t in range(N):
            cost += cp.quad_form(X[:, t] - target_x_vec.flatten(), Q)
            cost += cp.quad_form(Y[:, t] - target_y_vec.flatten(), Q)
            cost += cp.quad_form(Ux[:, t], R) + cp.quad_form(Uy[:, t], R)
            constraints.append(X[:, t+1] == A @ X[:, t] + B @ Ux[:, t])
            constraints.append(Y[:, t+1] == A @ Y[:, t] + B @ Uy[:, t])

        prob = cp.Problem(cp.Minimize(cost), constraints)
        prob.solve(solver=cp.OSQP)  # Use OSQP for better performance

        if prob.status in ["infeasible", "unbounded"]:
            return u_cache  # Use last known control if solving fails

        u_cache = np.array([[Ux[0, 0].value], [Uy[0, 0].value]])
        return u_cache

    except Exception as e:
        print(f"MPC Error: {e}")
        return u_cache  # Use previous control input on failure

running = True
while running:
    try:
        screen.fill(WHITE)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # Move red ball in a straight line, then turn occasionally
        if random.random() < 0.005:  # Lower chance of turning
            red_dx = random.choice([-1, 1])
            red_dy = random.choice([-1, 1])

        target_x += red_dx
        target_y += red_dy
        target_x = max(10, min(screen_width - 10, target_x))
        target_y = max(10, min(screen_height - 10, target_y))

        # Only run MPC every 10 frames
        if frame_counter % 10 == 0:
            u = mpc_control(target_x, target_y, x, y)
        else:
            u = u_cache  # Reuse previous control input

        x = A @ x + B @ u[0]
        y = A @ y + B @ u[1]

        x_pos = max(10, min(screen_width - 10, int(x[0, 0])))
        y_pos = max(10, min(screen_height - 10, int(y[0, 0])))

        # Debugging prints to ensure values are updating
        print(f"Red Ball: ({target_x}, {target_y}) | Blue Ball: ({x_pos}, {y_pos})")

        pygame.draw.circle(screen, RED, (target_x, target_y), 10)
        pygame.draw.circle(screen, BLUE, (x_pos, y_pos), 10)

        pygame.display.update()  # Ensure Pygame refreshes properly
        pygame.display.flip()

        clock.tick(10)  # Further reduce FPS to 10 for performance

        frame_counter += 1

    except Exception as e:
        print(f"Runtime Error: {e}")
        running = False

pygame.quit()